import argparse
import os
import json
import asyncio
import subprocess
from pathlib import Path
from urllib.parse import urlparse
from typing import Dict, Any, List

# Load environment variables from .env file
from dotenv import load_dotenv
# Try both paths - from agent dir and from parent dir
if os.path.exists("../.env"):
    load_dotenv(dotenv_path="../.env")
else:
    load_dotenv(dotenv_path=".env")

from agent.src.browser_navigator import BrowserNavigator
from agent.src.code_apply import apply_code_changes, parse_yaml_performance_report, convert_to_yaml
from agent.src.utils import read_report_with_check
from crewai import LLM


class ReportApplyFlow:
    """Flow to apply performance suggestions from a report to a website"""
    
    def __init__(self, report_path: str, url: str, device: str = 'desktop', headless: bool = True):
        self.report_path = Path(report_path)
        self.url = url
        self.device = device
        self.headless = headless
        self.output_dir = None
        self.suggestions = []
        
    def read_report(self) -> Dict[str, Any]:
        """Read the report generated by index.js"""
        print(f"📖 Reading report from: {self.report_path}")
        
        # Check if it's a markdown summary file or JSON
        if self.report_path.suffix == '.md':
            # Read markdown content
            with open(self.report_path, 'r') as f:
                report_content = f.read()
            
            return {
                'url': self.url,
                'device': self.device,
                'content': report_content
            }
        else:
            # Handle JSON report
            with open(self.report_path, 'r') as f:
                report_data = json.load(f)
            
            return report_data
    
    async def fetch_website_assets(self):
        """Use BrowserNavigator to fetch and save website assets"""
        print(f"\n🌐 Fetching website assets from: {self.url}")
        
        navigator = BrowserNavigator(
            url=self.url,
            device=self.device,
            headless=self.headless,
            auto_save_assets=True,
            serve_cached_assets=False
        )
        
        try:
            await navigator.setup()
            
            # Create output directory structure
            root_hostname = urlparse(self.url).hostname
            self.output_dir = navigator.ensure_output_dirs(root_hostname)
            
            # Navigate and collect performance data
            perf_data, metrics, response = await navigator.eval_performance(self.output_dir)
            
            # Save page DOM
            page_content = await navigator.page.content()
            page_dom_path = self.output_dir / "page_dom.html"
            with open(page_dom_path, "w") as f:
                f.write(page_content)
            
            print(f"✅ Assets saved to: {self.output_dir}")
            print(f"✅ Page DOM saved to: {page_dom_path}")
            
            # Initialize git repo in output directory
            self._init_git_repo()
            
            # Allow time for any pending requests to complete
            await asyncio.sleep(0.5)
            
            return perf_data, metrics
            
        finally:
            await navigator.close()
    
    def _init_git_repo(self):
        """Initialize git repository in output directory"""
        if not (self.output_dir / '.git').exists():
            print(f"\n📦 Initializing git repository in: {self.output_dir}")
            subprocess.run(['git', 'init'], cwd=self.output_dir, check=True)
            subprocess.run(['git', 'add', '.'], cwd=self.output_dir, check=True)
            subprocess.run(['git', 'commit', '-m', 'Initial commit with original assets'], 
                         cwd=self.output_dir, check=True)
            subprocess.run(['git', 'branch', '-M', 'master'], cwd=self.output_dir, check=True)
    
    def parse_suggestions(self, report_content: str) -> List[Dict[str, Any]]:
        """Parse suggestions from the report content"""
        print(f"\n🔍 Parsing suggestions from report...")
        
        # Use LLM to convert report to structured YAML format
        # Configure for Azure OpenAI
        llm = LLM(
            model="azure/gpt-4o",
            base_url=os.getenv("AZURE_API_BASE"),
            api_key=os.getenv("AZURE_API_KEY")
        )
        yaml_response = convert_to_yaml(report_content, llm)
        suggestions = parse_yaml_performance_report(yaml_response)
        
        print(f"✅ Found {len(suggestions)} suggestions")
        self.suggestions = suggestions
        
        # Save structured suggestions to JSON file
        if suggestions and self.output_dir:
            # Save the YAML response
            yaml_file = self.output_dir / "suggestions.yaml"
            with open(yaml_file, 'w') as f:
                f.write(yaml_response)
            print(f"💾 Saved YAML suggestions to: {yaml_file}")
            
            # Save the parsed JSON version
            suggestions_file = self.output_dir / "parsed_suggestions.json"
            with open(suggestions_file, 'w') as f:
                json.dump(suggestions, f, indent=2)
            print(f"💾 Saved structured suggestions to: {suggestions_file}")
        
        return suggestions
    
    def apply_suggestions(self):
        """Apply each suggestion as a separate git commit"""
        print(f"\n🔧 Applying {len(self.suggestions)} suggestions...")
        
        for idx, suggestion in enumerate(self.suggestions, 1):
            print(f"\n--- Suggestion {idx}/{len(self.suggestions)} ---")
            print(f"Summary: {suggestion.get('summary', 'No summary')}")
            
            # Generate unique ID for this suggestion
            suggestion_id = f"perf-fix-{idx}"
            
            # Apply the code changes
            apply_code_changes(
                output_dir=str(self.output_dir),
                suggestion=suggestion,
                model_name="azure/gpt-4o",
                suggestion_id=suggestion_id
            )
            
            print(f"✅ Applied suggestion in branch: {suggestion_id}")
    
    async def retest_performance(self, branch_name: str = None):
        """Re-test performance with modified assets"""
        print(f"\n🔄 Re-testing performance with modified assets...")
        
        # Checkout specific branch if provided
        if branch_name:
            subprocess.run(['git', 'checkout', branch_name], 
                         cwd=self.output_dir, check=True)
        
        navigator = BrowserNavigator(
            url=self.url,
            device=self.device,
            headless=self.headless,
            auto_save_assets=False,
            serve_cached_assets=True  # Use modified local assets
        )
        
        try:
            await navigator.setup()
            
            # Re-test performance
            perf_data, metrics, response = await navigator.eval_performance(self.output_dir)
            
            # Extract key metrics
            lcp_score = self._extract_lcp_score(perf_data)
            
            print(f"✅ Re-test complete. LCP: {lcp_score}ms")
            
            # Allow time for any pending requests to complete
            await asyncio.sleep(0.5)
            
            return perf_data, metrics, lcp_score
            
        finally:
            await navigator.close()
    
    def _extract_lcp_score(self, perf_data: Dict) -> float:
        """Extract LCP score from performance data"""
        if 'data' in perf_data:
            # Last item's end time is typically the LCP
            return perf_data['data'][-1]['end']
        return 0
    
    async def run(self):
        """Execute the complete flow"""
        print("🚀 Starting Report Apply Flow\n")
        
        # Step 1: Read the report
        report_data = self.read_report()
        
        # Step 2: Fetch website assets
        await self.fetch_website_assets()
        
        # Step 3: Parse suggestions from report
        if isinstance(report_data, dict) and 'content' in report_data:
            suggestions = self.parse_suggestions(report_data['content'])
        else:
            # Handle other report formats
            suggestions = self.parse_suggestions(str(report_data))
        
        # Step 4: Apply suggestions
        if suggestions:
            self.apply_suggestions()
            
            # Step 5: Re-test performance for each branch
            print("\n📊 Performance comparison:")
            print("-" * 50)
            
            # Test original
            original_data, _, original_lcp = await self.retest_performance("master")
            print(f"Original LCP: {original_lcp}ms")
            
            # Test each suggestion branch
            for idx in range(1, len(suggestions) + 1):
                branch_name = f"perf-fix-{idx}"
                try:
                    _, _, modified_lcp = await self.retest_performance(branch_name)
                    improvement = original_lcp - modified_lcp
                    percent = (improvement / original_lcp) * 100 if original_lcp > 0 else 0
                    
                    print(f"{branch_name} LCP: {modified_lcp}ms "
                          f"({'✅ ' if improvement > 0 else '❌ '}"
                          f"{improvement:+.0f}ms, {percent:+.1f}%)")
                except Exception as e:
                    print(f"{branch_name}: Error - {str(e)}")
            
            # Return to master branch
            subprocess.run(['git', 'checkout', 'master'], 
                         cwd=self.output_dir, check=True)
        
        print("\n✅ Flow complete!")
        print(f"📁 All changes saved in: {self.output_dir}")


async def main():
    parser = argparse.ArgumentParser(
        description='Apply performance suggestions from a report to a website'
    )
    parser.add_argument(
        'report_path',
        help='Path to the report file (markdown or JSON)'
    )
    parser.add_argument(
        'url',
        help='URL of the website to analyze'
    )
    parser.add_argument(
        '--device',
        choices=['desktop', 'mobile'],
        default='desktop',
        help='Device profile to use (default: desktop)'
    )
    parser.add_argument(
        '--headless',
        action='store_true',
        help='Run browser in headless mode'
    )
    
    args = parser.parse_args()
    
    # Create and run the flow
    flow = ReportApplyFlow(
        report_path=args.report_path,
        url=args.url,
        device=args.device,
        headless=args.headless
    )
    
    await flow.run()


if __name__ == "__main__":
    asyncio.run(main()) 